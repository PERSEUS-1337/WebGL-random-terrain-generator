<!DOCTYPE html>
<html>

<head>
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;
      attribute vec3 aOffset;  // Attribute for instance offset

      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uNormalMatrix;
      
      uniform vec4 uMaterialDiffuseColor;
      uniform vec4 uLightDiffuseColor;
      uniform vec4 uLightDirectionVector;

      varying vec4 vDiffuseColor;

      void main() {
        // Apply the instance offset
        vec4 position = aPosition + vec4(aOffset, 0.0);

        gl_Position = uProjectionMatrix * uViewMatrix * position;

        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);

        float lambertCoefficient = max(dot(-normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        vec4 diffuseColor =  uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient;

        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fshader">
      precision mediump float;
      varying vec4 vDiffuseColor;
      void main() {
        gl_FragColor = vDiffuseColor;
      }
    </script>

    <script src="./lib/webgl-init.js"></script>
    <script src="./lib/webgl-utils.js"></script>
    <script src="./lib/webgl-debug.js"></script>
    <script src="./lib/gl-matrix-min.js"></script>
</head>

<body>
    <canvas id="main_canvas" width="800" height="800" style="border: 1px black solid;"></canvas>

    <script>
        var canvas = document.getElementById("main_canvas");
        var gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!gl) {
            console.log("Failed to retrieve the WebGL context");
        }

        var vertexShader = initializeShader(gl, "vshader");
        var fragmentShader = initializeShader(gl, "fshader");
        var program = initializeProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(program);

        var aPositionPointer = gl.getAttribLocation(program, "aPosition");
        var aNormalPointer = gl.getAttribLocation(program, "aNormal");
        var aOffsetPointer = gl.getAttribLocation(program, "aOffset");

        var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
        var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
        var uNormalMatrixPointer = gl.getUniformLocation(program, "uNormalMatrix");
        var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
        var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
        var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        var modelMatrix;
        var viewMatrix;
        var projectionMatrix;

        /**START PROJECTION MATRIX SPECIFICATION**/
        var fieldOfViewYAxis = glMatrix.toRadian(30);
        var aspectRatio = canvas.width / canvas.height;
        var nearPlane = 1;
        var farPlane = 1000;

        projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, glMatrix.toRadian(30), canvas.width / canvas.height, 1, 1000);
        gl.uniformMatrix4fv(uProjectionMatrixPointer, false, projectionMatrix);

        /**START VIEW MATRIX SPECIFICATION**/
        var lookAtPoint = [0.0, 0.0, 0.0, 1.0];              //where the camera is looking
        var eyePoint = [-6.0, 8.0, -10.0, 1.0];              //where the camera is placed
        var upVector = [0.0, 1.0, 0.0, 0.0];              //orientation of the camera

        viewMatrix = mat4.create();
        mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
        gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
        
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);
        //gl.uniformMatrix4fv(uModelMatrixPointer,false,new Float32Array(modelMatrix));

        var normalMatrix = mat4.create();
        mat4.invert(normalMatrix, modelMatrix);
        mat4.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix4fv(uNormalMatrixPointer, false, normalMatrix);

        gl.uniform4f(uMaterialDiffuseColorPtr, 0.0, 1.0, 0.0, 1.0);
        gl.uniform4f(uLightDiffuseColorPtr, 1.0, 1.0, 1.0, 1.0);
        gl.uniform4f(uLightDirectionVectorPtr, 5.0, -5.0, 5.0, 0.0);

        var vertices = [
            -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,
            1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0
        ];

        for (var i = 0; i < vertices.length; i += 4) {
            vertices[i] *= 0.1;
            vertices[i + 1] *= 0.1;
            vertices[i + 2] *= 0.1;
        }

        var indices = [
            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11,
            12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
        ];

        var normals = [
            0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0,
            0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0
        ];

        const numCubes = 101;
        const cubeSize = 0.2;

        var allNormals = [];
        for (var i = 0; i < numCubes * numCubes; i++) {
            allNormals.push(...normals);
        }

        // Generate a random height increment between 0.1 and 1
        var offsets = [];
        for (var row = 0; row < numCubes; row++) {
            for (var col = 0; col < numCubes; col++) {
                var height = 0.1 + Math.random() * 0.9; // Height between 0.1 and 1
                var x = col * cubeSize * 1 - numCubes * cubeSize;
                var y = height * cubeSize; // Apply height directly
                var z = row * cubeSize * 1 - numCubes * cubeSize;
                offsets.push(x, y, z);
            }
        }

        var cubeColors = [];
        // Generate random colors for each cube
        for (var i = 0; i < numCubes*numCubes; i++) {
            var color = [Math.random(), Math.random(), Math.random(), 1.0];
            cubeColors.push(color);
        }
    
        var vertexBuffer = gl.createBuffer();
        var indexBuffer = gl.createBuffer();
        var normalBuffer = gl.createBuffer();
        var offsetBuffer = gl.createBuffer();

        function drawScene(){        
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(offsets), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
            gl.vertexAttribPointer(aOffsetPointer, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aOffsetPointer);
            gl.vertexAttribDivisor(aOffsetPointer, 1);  // This tells WebGL to use this attribute as instanced data

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            if (gl.drawArraysInstanced) {
                gl.drawElementsInstanced(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, numCubes * numCubes);
            } else {
                var ext = gl.getExtension("ANGLE_instanced_arrays");
                ext.drawElementsInstancedANGLE(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, numCubes * numCubes);
            }
        }

        drawScene();
    </script>
<script src="./src/lookcontrols.js"></script>

</body>

</html>