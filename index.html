<!DOCTYPE html>
<html>

<head>
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;
      attribute vec3 aOffset;  // Attribute for instance offset
      attribute vec4 color;

      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uNormalMatrix;
      
      uniform vec4 uMaterialDiffuseColor;
      uniform vec4 uLightDiffuseColor;
      uniform vec4 uLightDirectionVector;

      uniform vec4 uAmbientLight;

      varying vec4 vDiffuseColor;

      void main() {
        // Apply the instance offset
        vec4 position = aPosition + vec4(aOffset, 0.0);

        gl_Position = uProjectionMatrix * uViewMatrix * position;

        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);

        float lambertCoefficient = max(dot(-normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        vec4 diffuseColor = (uAmbientLight + uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient)*color;

        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fshader">
      precision mediump float;
      varying vec4 vDiffuseColor;
      void main() {
        gl_FragColor = vDiffuseColor;
      }
    </script>

    <script src="./lib/webgl-init.js"></script>
    <script src="./lib/webgl-utils.js"></script>
    <script src="./lib/webgl-debug.js"></script>
    <script src="./lib/gl-matrix-min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Terrain Generator</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* Prevent scrollbars */
            background-color: #000000;
            position: relative;
            /* Make body the positioning context */
        }

        canvas {
            display: block;
            /* Ensure canvas is treated as a block element */
            border: 1px black solid;
            width: 100vw;
            /* Full width of viewport */
            height: 100vh;
            /* Full height of viewport */
            position: absolute;
            top: 0;
            left: 0;
        }

        #controls {
            position: absolute;
            top: 20px;
            /* Adjust the top position as needed */
            left: 20px;
            /* Adjust the left position as needed */
            color: #000000;
            /* White text color */
            z-index: 1;
            /* Ensure controls render on top of the canvas */
            background-color: white;
            padding: 10px;
            opacity: 100%;
            transition: opacity 2s ease;
        }

        #controls:hover {
            opacity: 100%;
        }
    </style>
</head>

<body>
    <div id="controls" class="opacity-50 container-w-20-shadow-lg p-3 mb-5 bg-white rounded">
        <label for="matrix-size">Matrix Size (N):</label>
        <input type="number" id="matrix-size" value="50" min="10" step="1">
        <br>
        <label for="max-elevation">Max Elevation:</label>
        <input type="number" id="max-elevation" value="10" min="1" step="1">
        <br>
        <label for="min-elevation">Min Elevation:</label>
        <input type="number" id="min-elevation" value="0" min="0" step="1">
        <br>
        <label for="anchor-percent">Anchor Percent:</label>
        <input type="number" id="anchor-percent" value="0.01" max="1" step="0.0005">
        <br>
        <label for="closest-anchor-count">Closest Anchor Count:</label>
        <input type="number" id="closest-anchor-count" value="4" min="1" step="1">
        <br>
        <button id="regenerate-button" class="btn btn-primary">Regenerate</button>

        <br><br>
        <hr>
        <label>Time:</label>
        <span id="timeDisplay">12:00</span>
        <input class='range' type="range" id="timeSlider" min="0" max="1440" step="1" value="720">
        <br>
        <button id="dayNightCycle" class="btn btn-primary">Start Day/Night Cycle</button>
        <br><br>
        <hr>
        <label>Presets:</label>
        <br>
        <label for="presets">Choose a preset:</label>
        <select name="presets" id="presets">
            <option value="default">Default</option>
            <option value="recommended-maximum"> Recommended Maximum</option>
        </select>
        <br>
        <button id="generate-preset-button" class="btn btn-primary">Generate Preset</button>
        <hr>
        <button id="autoRotate" class="btn btn-primary">Start Auto Rotate</button>
        <br><br>
        <button id="resetCam" class="btn btn-primary">Reset Camera</button>
    </div>
    <canvas id="main_canvas" width="1400" height="720"></canvas>
    <script src="./src/rng.js"></script>
    <script>
        // Fade out the controls after two seconds. This only happens once.
        setTimeout(function () {
            document.getElementById('controls').style.opacity = '0';
        }, 2000);

        // Add event listeners to control the hover effect
        document.getElementById('controls').addEventListener('mouseover', function () {
            this.style.opacity = '1';
        });

        document.getElementById('controls').addEventListener('mouseout', function () {
            this.style.opacity = '0';
        });
    </script>
    <script>
        var canvas = document.getElementById("main_canvas");
        var gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!gl) {
            console.log("Failed to retrieve the WebGL context");
        }

        var vertexShader = initializeShader(gl, "vshader");
        var fragmentShader = initializeShader(gl, "fshader");
        var program = initializeProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(program);

        var aPositionPointer = gl.getAttribLocation(program, "aPosition");
        var aNormalPointer = gl.getAttribLocation(program, "aNormal");
        var aOffsetPointer = gl.getAttribLocation(program, "aOffset");
        var colorPointer = gl.getAttribLocation(program, "color");

        var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
        var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
        var uNormalMatrixPointer = gl.getUniformLocation(program, "uNormalMatrix");
        var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
        var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
        var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
        var uAmbientLightPtr = gl.getUniformLocation(program, "uAmbientLight");

        var skyColor = [0.8235, 0.9686, 1, 1];
        gl.clearColor(skyColor[0], skyColor[1], skyColor[2], skyColor[3]);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        var numCubes = parseFloat(document.getElementById("matrix-size").value);
        const cubeSize = 0.2;

        var modelMatrix;
        var viewMatrix;
        var projectionMatrix;

        /**START PROJECTION MATRIX SPECIFICATION**/
        var fieldOfViewYAxis = glMatrix.toRadian(30);
        var aspectRatio = canvas.width / canvas.height;
        var nearPlane = 1;
        var farPlane = 1000;

        projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, glMatrix.toRadian(30), canvas.width / canvas.height, 1, 1000);
        gl.uniformMatrix4fv(uProjectionMatrixPointer, false, projectionMatrix);

        /**START VIEW MATRIX SPECIFICATION**/
        var lookAtPoint = [-(numCubes*cubeSize)/2, 0.0, -(numCubes*cubeSize)/2, 1.0];   //where the camera is looking
        var eyePoint = [-(numCubes*cubeSize)*2, (numCubes*cubeSize), -(numCubes*cubeSize)*2, 1.0];  //where the camera is placed
        var upVector = [0.0, 1.0, 0.0, 0.0];              //orientation of the camera

        viewMatrix = mat4.create();
        mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
        gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));

        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);
        //gl.uniformMatrix4fv(uModelMatrixPointer,false,new Float32Array(modelMatrix));

        var normalMatrix = mat4.create();
        mat4.invert(normalMatrix, modelMatrix);
        mat4.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix4fv(uNormalMatrixPointer, false, normalMatrix);

        var lightDiffuseColor = [1.0, 1.0, 1.0, 1.0];
        var lightDirection = [0, -1, 0.75, 0.0];
        var lightAmbient = [0.1, 0.1, 0.1, 1.0];

        gl.uniform4f(uMaterialDiffuseColorPtr, 0.596, 0.576, 0.855, 1.0);
        gl.uniform4fv(uLightDiffuseColorPtr, lightDiffuseColor);
        gl.uniform4fv(uLightDirectionVectorPtr, lightDirection);
        gl.uniform4fv(uAmbientLightPtr, lightAmbient);

        var vertices = [
            -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,
            1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0
        ];

        for (var i = 0; i < vertices.length; i += 4) {
            vertices[i] *= 0.1;
            vertices[i + 1] *= 0.1;
            vertices[i + 2] *= 0.1;
        }

        var indices = [
            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11,
            12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
        ];

        var normals = [
            0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0,
            0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0
        ];

        var allNormals = [];
        for (var i = 0; i < numCubes * numCubes; i++) {
            allNormals.push(...normals);
        }

        // RNG HEIGHT GENERATION
        MAX_ELEV = parseFloat(document.getElementById("max-elevation").value);
        MIN_ELEV = parseFloat(document.getElementById("min-elevation").value);
        ANCHOR_PERCENT = parseFloat(document.getElementById("anchor-percent").value);
        CLOSEST_ANCHOR_COUNT = parseFloat(document.getElementById("closest-anchor-count").value);
        let anchorCount = Math.floor(numCubes * numCubes * ANCHOR_PERCENT);
        let randomCoordinates = getRandomCoordinates(numCubes, anchorCount, MIN_ELEV, MAX_ELEV);
        let randMatx = Array.from({ length: numCubes }, () => Array(numCubes).fill(0));
        populateMatx(randMatx, randomCoordinates);
        terrainInter(randMatx, numCubes, randomCoordinates, CLOSEST_ANCHOR_COUNT);

        var colorBuffer = gl.createBuffer();
        var vertexBuffer = gl.createBuffer();
        var indexBuffer = gl.createBuffer();
        var normalBuffer = gl.createBuffer();
        var offsetBuffer = gl.createBuffer();

        function drawScene() {
            var offsets = [];
            var colors = [];
            var gap = MAX_ELEV * cubeSize;
            // gap = ((numCubes*numCubes)/5)*0.1;
            var gaps = getHeightGaps(randMatx, gap);
            var gapCount = [0, 0, 0, 0, 0];
            var flag = [0, 0, 0, 0, 0];
            var sorted = [];

            for (var row = 0; row < numCubes; row++) {
                for (var col = 0; col < numCubes; col++) {
                    var height = randMatx[row][col]
                    var x = col * cubeSize * 1 - numCubes * cubeSize;
                    var y = height * cubeSize; // Apply height directly
                    var z = row * cubeSize * 1 - numCubes * cubeSize;
                    offsets.push(x, y, z);

                    var colorResult = getColor(y, gap);
                    var colorList = colorResult[1].map(function (value) {
                        return value * (y);
                    });
                    colorList.forEach((value) => colors.push(value));
                }
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(offsets), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
            gl.vertexAttribPointer(aOffsetPointer, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aOffsetPointer);
            gl.vertexAttribDivisor(aOffsetPointer, 1);  // This tells WebGL to use this attribute as instanced data

            // ADD COLORS
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(colorPointer);
            gl.vertexAttribPointer(colorPointer, 4, gl.FLOAT, false, 0, 0);
            gl.vertexAttribDivisor(colorPointer, 1);

            gl.clearColor(skyColor[0], skyColor[1], skyColor[2], skyColor[3]);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            if (gl.drawArraysInstanced) {
                gl.drawElementsInstanced(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, numCubes * numCubes);
            } else {
                var ext = gl.getExtension("ANGLE_instanced_arrays");
                ext.drawElementsInstancedANGLE(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, numCubes * numCubes);
            }
        }

        function getHeightGaps(mat, gap) {
            var gapRet = [0, 0, 0, 0, 0];

            for (let i = 0; i < mat.length; i++) {
                for (let j = 0; j < mat[i].length; j++) {
                    gapRet[getColor((mat[i][j] * cubeSize), gap)[0]]++;
                }
            }
            return gapRet;
        }

        function getColor(y, gap) {
            switch (true) {
                case y <= gap * (1 / 5):
                    return [0, [0.35686275, 0.7372549, 1.0, 1.0]]; // dark then light blue

                case y <= gap * (2 / 5):
                    return [2, [0.69411765, 0.57254902, 0.39215686, 1.0]]; // sand

                case y <= gap * (3 / 5):
                    return [1, [0.25098039, 0.64705882, 0.47058824, 1.0]];  // green

                case y <= gap * (4 / 5):
                    return [3, [0.65098039, 0.3372549, 0.06666667, 1.0]]; // brown 

                default:
                    return [4, [1.0, 1.0, 1.0, 1.0]]; // white
            }
        }
        function generate(){
            // Fetch new values for the matrix
            numCubes = parseInt(document.getElementById("matrix-size").value);
            MAX_ELEV = parseInt(document.getElementById("max-elevation").value);
            MIN_ELEV = parseInt(document.getElementById("min-elevation").value);
            ANCHOR_PERCENT = parseFloat(document.getElementById("anchor-percent").value);
            CLOSEST_ANCHOR_COUNT = parseInt(
                document.getElementById("closest-anchor-count").value
            );

            // Reinitialize the matrices
            anchorCount = Math.floor(numCubes * numCubes * ANCHOR_PERCENT);
            randomCoordinates = getRandomCoordinates(numCubes, anchorCount, MIN_ELEV, MAX_ELEV);
            randMatx = Array.from({ length: numCubes }, () => Array(numCubes).fill(0));
            populateMatx(randMatx, randomCoordinates);
            terrainInter(randMatx, numCubes, randomCoordinates, CLOSEST_ANCHOR_COUNT);

            offsets = [];
            for (var row = 0; row < numCubes; row++) {
                for (var col = 0; col < numCubes; col++) {
                    var height = randMatx[row][col];
                    var x = col * cubeSize * 1 - numCubes * cubeSize;
                    var y = height * cubeSize; // Apply height directly
                    // console.log(y);
                    var z = row * cubeSize * 1 - numCubes * cubeSize;
                    offsets.push(x, y, z);
                }
            }
            console.log(randMatx)
            resetCamera();
            drawScene();
        }
        document.getElementById("regenerate-button").addEventListener("click", () => {
            generate();
        });
        //presets
        const presets = {
            "default": [50, 10, 0, 0.01, 4],
            "recommended-maximum": [200, 10, 0, 0.01, 4]

        };
        document.getElementById("generate-preset-button").addEventListener("click", () => {
            const preset = document.getElementById("presets").value;
            const preset_values = presets[preset];
            var matrixSize = document.getElementById('matrix-size');
            var maxElevation = document.getElementById('max-elevation');
            var minElevation = document.getElementById('min-elevation');
            var anchorPercent = document.getElementById('anchor-percent');
            var closestAnchorCount = document.getElementById('closest-anchor-count');
            matrixSize.value = preset_values[0];
            maxElevation.value = preset_values[1];
            minElevation.value = preset_values[2];
            anchorPercent.value = preset_values[3];
            closestAnchorCount.value = preset_values[4];

            generate();
        });

        // Finally, draw the scene
        drawScene();
    </script>
    <script src="./src/lookcontrols.js"></script>
    <script src="./src/lighting.js"></script>

</body>

</html>