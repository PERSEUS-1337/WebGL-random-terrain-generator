<!DOCTYPE html>
<html>

<head>
    <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;
      attribute vec3 aOffset;  // Attribute for instance offset

      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uNormalMatrix;
      
      uniform vec4 uMaterialDiffuseColor;
      uniform vec4 uLightDiffuseColor;
      uniform vec4 uLightDirectionVector;

      varying vec4 vDiffuseColor;

      void main() {
        // Apply the instance offset
        vec4 position = aPosition + vec4(aOffset, 0.0);

        gl_Position = uProjectionMatrix * uViewMatrix * position;

        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);

        float lambertCoefficient = max(dot(-normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        vec4 diffuseColor =  uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient;

        vDiffuseColor = vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fshader">
      precision mediump float;
      varying vec4 vDiffuseColor;
      void main() {
        gl_FragColor = vDiffuseColor;
      }
    </script>

    <script src="./lib/webgl-init.js"></script>
    <script src="./lib/webgl-utils.js"></script>
    <script src="./lib/webgl-debug.js"></script>
    <script src="./lib/gl-matrix-min.js"></script>

    <script src="./src/rng.js"></script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Terrain Generator</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000;
            position: relative; /* Make body the positioning context */
        }
        canvas {
            display: block; /* Ensure canvas is treated as a block element */
            border: 1px black solid;
            width: 100vw; /* Full width of viewport */
            height: 100vh; /* Full height of viewport */
            position: absolute;
            top: 0;
            left: 0;
        }
        .controls {
            position: absolute;
            top: 20px; /* Adjust the top position as needed */
            left: 20px; /* Adjust the left position as needed */
            color: #ffffff; /* White text color */
            z-index: 1; /* Ensure controls render on top of the canvas */
        }
    </style>
</head>

<body>
    <div class="controls">
        <label for="matrix-size">Matrix Size (N):</label>
        <input type="number" id="matrix-size" value="100" min="10" step="1">
        <br>
        <label for="max-elevation">Max Elevation:</label>
        <input type="number" id="max-elevation" value="10" min="1" step="1">
        <br>
        <label for="anchor-percent">Anchor Percent:</label>
        <input type="number" id="anchor-percent" value="0.01" min="0.01" max="1" step="0.01">
        <br>
        <label for="closest-anchor-count">Closest Anchor Count:</label>
        <input type="number" id="closest-anchor-count" value="4" min="1" step="1">
                <br>
        <button id="regenerate-button">Regenerate</button>
    </div>
    <canvas id="main_canvas" width="1280" height="720"></canvas>

    <script>
        var canvas = document.getElementById("main_canvas");
        var gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
        if (!gl) {
            console.log("Failed to retrieve the WebGL context");
        }

        var vertexShader = initializeShader(gl, "vshader");
        var fragmentShader = initializeShader(gl, "fshader");
        var program = initializeProgram(gl, vertexShader, fragmentShader);
        gl.useProgram(program);

        var aPositionPointer = gl.getAttribLocation(program, "aPosition");
        var aNormalPointer = gl.getAttribLocation(program, "aNormal");
        var aOffsetPointer = gl.getAttribLocation(program, "aOffset");

        var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
        var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
        var uNormalMatrixPointer = gl.getUniformLocation(program, "uNormalMatrix");
        var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
        var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
        var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        var modelMatrix;
        var viewMatrix;
        var projectionMatrix;

        /**START PROJECTION MATRIX SPECIFICATION**/
        var fieldOfViewYAxis = glMatrix.toRadian(30);
        var aspectRatio = canvas.width / canvas.height;
        var nearPlane = 1;
        var farPlane = 1000;

        projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, glMatrix.toRadian(30), canvas.width / canvas.height, 1, 1000);
        gl.uniformMatrix4fv(uProjectionMatrixPointer, false, projectionMatrix);

        /**START VIEW MATRIX SPECIFICATION**/
        var lookAtPoint = [-5.0, 0.0, -5.0, 1.0];              //where the camera is looking
        var eyePoint = [7.0, 5.0, 7.0, 1.0];              //where the camera is placed
        var upVector = [0.0, 1.0, 0.0, 0.0];              //orientation of the camera

        viewMatrix = mat4.create();
        mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
        gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
        
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);
        //gl.uniformMatrix4fv(uModelMatrixPointer,false,new Float32Array(modelMatrix));

        var normalMatrix = mat4.create();
        mat4.invert(normalMatrix, modelMatrix);
        mat4.transpose(normalMatrix, normalMatrix);
        gl.uniformMatrix4fv(uNormalMatrixPointer, false, normalMatrix);

        gl.uniform4f(uMaterialDiffuseColorPtr, 0.596, 0.576, 0.855, 1.0);
        gl.uniform4f(uLightDiffuseColorPtr, 1.0, 1.0, 1.0, 1.0);
        gl.uniform4f(uLightDirectionVectorPtr, -5.0, -3.0, 2.0, 0.0);

        var vertices = [
            -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0,
            -1.0, 1.0, -1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,
            1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,
            -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, 1.0
        ];

        for (var i = 0; i < vertices.length; i += 4) {
            vertices[i] *= 0.1;
            vertices[i + 1] *= 0.1;
            vertices[i + 2] *= 0.1;
        }

        var indices = [
            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11,
            12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
        ];

        var normals = [
            0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 0.0, -1.0, 1.0,
            0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
            0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0
        ];

        var numCubes = parseFloat(document.getElementById("matrix-size").value);
        const cubeSize = 0.2;

        var allNormals = [];
        for (var i = 0; i < numCubes * numCubes; i++) {
            allNormals.push(...normals);
        }

        // RNG HEIGHT GENERATION
        MAX_ELEV = parseFloat(document.getElementById("max-elevation").value);
        ANCHOR_PERCENT = parseFloat(document.getElementById("anchor-percent").value);
        CLOSEST_ANCHOR_COUNT = parseFloat(document.getElementById("closest-anchor-count").value);
        let anchorCount = Math.floor(numCubes * numCubes * ANCHOR_PERCENT);
        let randomCoordinates = getRandomCoordinates(numCubes, anchorCount);
        let randMatx = Array.from({ length: numCubes }, () => Array(numCubes).fill(0));
        randPopulateMatx(randMatx, randomCoordinates, MAX_ELEV);
        randTerrainInter(randMatx, numCubes, randomCoordinates, CLOSEST_ANCHOR_COUNT);
        var offsets = [];
        for (var row = 0; row < numCubes; row++) {
            for (var col = 0; col < numCubes; col++) {
                var height = randMatx[row][col]
                var x = col * cubeSize * 1 - numCubes * cubeSize;
                var y = height * cubeSize; // Apply height directly
                var z = row * cubeSize * 1 - numCubes * cubeSize;
                offsets.push(x, y, z);
            }
        }
        
        var cubeColors = [];
        // Generate random colors for each cube
        for (var i = 0; i < numCubes*numCubes; i++) {
            var color = [Math.random(), Math.random(), Math.random(), 1.0];
            cubeColors.push(color);
        }
    
        var vertexBuffer = gl.createBuffer();
        var indexBuffer = gl.createBuffer();
        var normalBuffer = gl.createBuffer();
        var offsetBuffer = gl.createBuffer();

        function drawScene() {
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(allNormals), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(offsets), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPositionPointer);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNormalPointer);

            gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
            gl.vertexAttribPointer(aOffsetPointer, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aOffsetPointer);
            gl.vertexAttribDivisor(aOffsetPointer, 1);  // This tells WebGL to use this attribute as instanced data

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            if (gl.drawArraysInstanced) {
                gl.drawElementsInstanced(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, numCubes * numCubes);
            } else {
                var ext = gl.getExtension("ANGLE_instanced_arrays");
                ext.drawElementsInstancedANGLE(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, numCubes * numCubes);
            }
        }

        drawScene();

        document.getElementById("regenerate-button").addEventListener("click", () => {
            // Fetch new values for the matrix
            numCubes = parseInt(document.getElementById("matrix-size").value);
            MAX_ELEV = parseInt(document.getElementById("max-elevation").value);
            ANCHOR_PERCENT = parseFloat(
                document.getElementById("anchor-percent").value
            );
            CLOSEST_ANCHOR_COUNT = parseInt(document.getElementById("closest-anchor-count").value);

            // Reinitialize the matrices
            anchorCount = Math.floor(numCubes * numCubes * ANCHOR_PERCENT);
            randomCoordinates = getRandomCoordinates(numCubes, anchorCount);
            randMatx = Array.from({ length: numCubes }, () => Array(numCubes).fill(0));
            randPopulateMatx(randMatx, randomCoordinates, MAX_ELEV);
            randTerrainInter(randMatx, numCubes, randomCoordinates, CLOSEST_ANCHOR_COUNT);
            offsets = [];
            for (var row = 0; row < numCubes; row++) {
                for (var col = 0; col < numCubes; col++) {
                    var height = randMatx[row][col]
                    var x = col * cubeSize * 1 - numCubes * cubeSize;
                    var y = height * cubeSize; // Apply height directly
                    // console.log(y);
                    var z = row * cubeSize * 1 - numCubes * cubeSize;
                    offsets.push(x, y, z);
                }
            }

            drawScene();
        });
    </script>
    <script src="./src/lookcontrols.js"></script>

</body>
</html>